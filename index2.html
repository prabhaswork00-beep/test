<!-- 2 -->
<!-- working -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Prevent caching while developing -->
    <meta http-equiv="cache-control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="pragma" content="no-cache">
    <meta http-equiv="expires" content="0">
    <title>Chess Grandmaster AI Trainer — UPDATED</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700;900&family=IBM+Plex+Mono:wght@400;600&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0f0f0f;
            --bg-secondary: #1a1a1a;
            --accent-gold: #d4af37;
            --accent-silver: #c0c0c0;
            --text-primary: #ffffff;
            --text-secondary: #a0a0a0;
            --success: #4ade80;
            --warning: #fbbf24;
            --error: #ef4444;
            --board-light: #f0d9b5;
            --board-dark: #b58863;
            --highlight: rgba(212, 175, 55, 0.4);
        }

        body {
            font-family: 'IBM Plex Mono', monospace;
            background: linear-gradient(135deg, #0f0f0f 0%, #1a1a2e 100%);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .grain-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('data:image/svg+xml;utf8,<svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"><filter id="noise"><feTurbulence type="fractalNoise" baseFrequency="0.9" numOctaves="4" stitchTiles="stitch"/></filter><rect width="100%" height="100%" filter="url(%23noise)" opacity="0.05"/></svg>');
            pointer-events: none;
            z-index: 1000;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 2rem;
            position: relative;
            z-index: 1;
        }

        header {
            text-align: center;
            margin-bottom: 3rem;
            animation: fadeInDown 0.8s ease-out;
        }

        h1 {
            font-family: 'Playfair Display', serif;
            font-size: 4rem;
            font-weight: 900;
            background: linear-gradient(135deg, var(--accent-gold) 0%, var(--accent-silver) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
            letter-spacing: -2px;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1.1rem;
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 600px 1fr;
            gap: 2rem;
            align-items: start;
        }

        .board-container {
            position: relative;
            animation: fadeIn 1s ease-out 0.2s both;
        }

        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 600px;
            height: 600px;
            border: 4px solid var(--accent-gold);
            box-shadow: 0 20px 60px rgba(212, 175, 55, 0.3);
            margin: 0 auto;
            position: relative;
        }

        .square {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3.5rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            user-select: none;
        }

        /* Swapped board colors (white/dark interchanged) ✅ */
        .square.light {
            background: var(--board-dark);
        }

        .square.dark {
            background: var(--board-light);
        }

        .square.selected {
            background: var(--highlight) !important;
            box-shadow: inset 0 0 20px rgba(212, 175, 55, 0.6);
        }

        .square.possible-move::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
        }

        .square.possible-move.has-piece::after {
            width: 100%;
            height: 100%;
            background: transparent;
            border: 3px solid rgba(212, 175, 55, 0.6);
            border-radius: 0;
        }

        .piece {
            transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
            filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.3));
        }

        /* Inverted piece colors: white pieces appear dark, black pieces appear light */
        .white-piece { color: #111; text-shadow: none; }
        .black-piece { color: #fff; text-shadow: 0 1px 0 rgba(0,0,0,0.2); }

        /* King-in-check highlight */
        .king-check {
            box-shadow: inset 0 0 30px rgba(255, 0, 0, 0.5);
            background: rgba(255, 0, 0, 0.08) !important;
        }
        /* AI suggestion highlights */
        .suggest-from {
            outline: 3px solid rgba(0, 200, 50, 0.9);
            box-shadow: 0 0 18px rgba(0,200,50,0.18);
        }
        .suggest-to {
            outline: 3px solid rgba(50, 150, 255, 0.95);
            box-shadow: 0 0 22px rgba(50,150,255,0.16);
        }
        .suggest-line {
            background: rgba(212,175,55,0.08) !important;
        }

        .piece.moving {
            animation: pieceMove 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        @keyframes pieceMove {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.2) translateY(-20px);
            }
            100% {
                transform: scale(1);
            }
        }

        .panel {
            background: rgba(26, 26, 26, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(212, 175, 55, 0.2);
            border-radius: 12px;
            padding: 2rem;
            animation: fadeIn 1s ease-out 0.4s both;
        }

        .panel h2 {
            font-family: 'Playfair Display', serif;
            font-size: 1.8rem;
            color: var(--accent-gold);
            margin-bottom: 1.5rem;
            border-bottom: 2px solid rgba(212, 175, 55, 0.3);
            padding-bottom: 0.5rem;
        }

        .api-setup {
            margin-bottom: 2rem;
        }

        .input-group {
            margin-bottom: 1rem;
        }

        .input-group label {
            display: block;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .input-group input {
            width: 100%;
            padding: 0.75rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(212, 175, 55, 0.3);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9rem;
            transition: all 0.3s;
        }

        .input-group input:focus {
            outline: none;
            border-color: var(--accent-gold);
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.2);
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: 2px solid var(--accent-gold);
            background: transparent;
            color: var(--accent-gold);
            font-family: 'IBM Plex Mono', monospace;
            font-weight: 600;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: var(--accent-gold);
            transition: left 0.3s;
            z-index: -1;
        }

        .btn:hover::before {
            left: 0;
        }

        .btn:hover {
            color: var(--bg-primary);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: var(--accent-gold);
            color: var(--bg-primary);
        }

        .btn-group {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .btn-small {
            padding: 0.5rem 1rem;
            font-size: 0.8rem;
        }

        .analysis-section {
            background: rgba(0, 0, 0, 0.3);
            border-left: 3px solid var(--accent-gold);
            padding: 1rem;
            margin-top: 1rem;
            border-radius: 6px;
            min-height: 100px;
        }

        .analysis-section h3 {
            color: var(--accent-silver);
            font-size: 1rem;
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .analysis-content {
            color: var(--text-secondary);
            line-height: 1.6;
            font-size: 0.9rem;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(212, 175, 55, 0.3);
            border-radius: 50%;
            border-top-color: var(--accent-gold);
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .move-history {
            max-height: 400px;
            overflow-y: auto;
            margin-top: 1rem;
        }

        .move-item {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            border-left: 3px solid transparent;
            cursor: pointer;
            transition: all 0.3s;
        }

        .move-item:hover {
            background: rgba(212, 175, 55, 0.1);
            border-left-color: var(--accent-gold);
        }

        .move-item.active {
            background: rgba(212, 175, 55, 0.2);
            border-left-color: var(--accent-gold);
        }

        .move-number {
            color: var(--accent-gold);
            font-weight: 600;
            margin-right: 0.5rem;
        }

        .status-bar {
            text-align: center;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            margin-top: 1rem;
        }

        .status-bar.check {
            background: rgba(251, 191, 36, 0.2);
            border: 1px solid var(--warning);
        }

        .status-bar.checkmate {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid var(--error);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 1.5rem;
        }
        /* Promotion modal compact button */
        .promo-option {
            min-width: 90px;
            text-align: center;
        }
        /* AI button states */
        .btn.ai-enabled {
            background: var(--accent-gold);
            color: var(--bg-primary);
            border-color: var(--accent-gold);
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(212, 175, 55, 0.4);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(212, 175, 55, 0.6);
        }

        .score-display {
            font-size: 1.2rem;
            margin: 1rem 0;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            text-align: center;
        }

        .score-display .score {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-gold);
        }
    </style>
</head>
<body>
    <div class="grain-overlay"></div>

    <div class="container">
        <header>
            <h1>GRANDMASTER — UPDATED</h1>
            <p class="subtitle">AI Chess Trainer • Build: 2026-01-31</p>
        </header>

        <div class="main-grid">
            <!-- Left Panel: AI Analysis -->
            <div class="panel">
                <h2>AI Coach</h2>

                <div class="api-setup">
                    <div class="input-group">
                        <label>OpenAI API Key</label>
                        <input type="password" id="apiKey" placeholder="sk-...">
                    </div>
                    <button class="btn btn-primary" onclick="saveApiKey()">Save API Key</button>
                </div>

                <div class="btn-group">
                    <button class="btn btn-small" onclick="analyzeBeforeMove()" id="beforeMoveBtn">
                        Analyze Before Move
                    </button>
                    <button class="btn btn-small" onclick="analyzeAfterMove()" id="afterMoveBtn" disabled>
                        Analyze After Move
                    </button>
                </div>

                <div class="analysis-section">
                    <h3>AI Analysis</h3>
                    <div class="analysis-content" id="analysisContent">
                        Set your API key and make a move to get AI coaching.
                    </div>
                </div>

                <div class="score-display">
                    <div>Position Evaluation</div>
                    <div class="score" id="scoreDisplay">0.0</div>
                </div>
            </div>

            <!-- Center: Chess Board -->
            <div class="board-container">
                <div class="chessboard" id="chessboard"></div>

                <div class="controls">
                    <button class="btn btn-small" onclick="previousMove()" id="prevBtn" disabled>
                        ← Previous
                    </button>
                    <button class="btn btn-small" onclick="resetGame()">
                        Reset Game
                    </button>
                    <button class="btn btn-small" onclick="nextMove()" id="nextBtn" disabled>
                        Next →
                    </button>
                    <!-- AI Controls (toggle + difficulty + side) -->
                    <div style="display:flex; gap:0.5rem; align-items:center; margin-left: 1rem;">
                        <button class="btn btn-small" id="toggleAiBtn" onclick="toggleAI()">Enable AI</button>
                        <select id="aiLevel" onchange="setAIDifficulty(this.value)" class="btn btn-small" style="padding:0.4rem 0.6rem;">
                            <option value="easy">Easy</option>
                            <option value="medium" selected>Medium</option>
                            <option value="hard">Hard</option>
                        </select>
                        <select id="aiPlays" onchange="setAIPlays(this.value)" class="btn btn-small" style="padding:0.4rem 0.6rem;">
                            <option value="black" selected>AI = Black</option>
                            <option value="white">AI = White</option>
                            <option value="none">AI = None</option>
                        </select>
                    </div>
                </div>

                <div class="status-bar" id="statusBar">
                    White to move
                </div>
            </div>

            <!-- Right Panel: Move History -->
            <div class="panel">
                <h2>Move History</h2>
                <div class="move-history" id="moveHistory">
                    <p style="color: var(--text-secondary);">Game not started</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Promotion modal -->
    <div id="promotionModal" style="display:none; position:fixed; inset:0; align-items:center; justify-content:center; z-index:2000;">
        <div style="background:rgba(0,0,0,0.85); padding:1.5rem; border-radius:12px; border:2px solid rgba(212,175,55,0.2); display:flex; gap:1rem; align-items:center;">
            <div style="color:var(--text-secondary); margin-right:0.5rem;">Promote pawn to:</div>
            <button class="btn btn-small promo-option" onclick="handlePromotionChoice('Q')">Queen ♕</button>
            <button class="btn btn-small promo-option" onclick="handlePromotionChoice('R')">Rook ♖</button>
            <button class="btn btn-small promo-option" onclick="handlePromotionChoice('B')">Bishop ♗</button>
            <button class="btn btn-small promo-option" onclick="handlePromotionChoice('N')">Knight ♘</button>
        </div>
    </div>
    <script>
        // Chess piece Unicode symbols
        const PIECES = {
            'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
            'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
        };

        // Initial board setup
        const INITIAL_BOARD = [
            ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
            ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ];

        let board = JSON.parse(JSON.stringify(INITIAL_BOARD));
        let selectedSquare = null;
        let currentPlayer = 'white';
        let moveHistory = [];
        let historyIndex = -1;
        let apiKey = '';
        let lastMoveMade = null;
        // AI & promotion state
        let aiEnabled = false;
        let aiLevel = 'medium'; // easy | medium | hard
        let aiPlays = 'black'; // black | white | none
        let pendingPromotion = null; // {row, col, color}
        // Advanced state flags
        let enPassantTarget = null; // {row, col} target square for en-passant capture
        let castling = { wK: true, wQ: true, bK: true, bQ: true }; // castling rights

        function toggleAI(){
            aiEnabled = !aiEnabled;
            const btn = document.getElementById('toggleAiBtn');
            if (aiEnabled) { btn.textContent = 'Disable AI'; btn.classList.add('ai-enabled'); }
            else { btn.textContent = 'Enable AI'; btn.classList.remove('ai-enabled'); }
            // If enabling and it's AI's turn, trigger AI move
            if (aiEnabled && aiPlays === currentPlayer && !isCheckmate(currentPlayer) && !isStalemate(currentPlayer)) {
                setTimeout(makeAIMove, 600);
            }
        }
        function setAIDifficulty(level){ aiLevel = level; }
        function setAIPlays(val){ aiPlays = val; if (val === 'none') aiEnabled = false; document.getElementById('toggleAiBtn').textContent = aiEnabled ? 'Disable AI' : 'Enable AI'; }
        function showPromotionModal(row, col, color) {
            pendingPromotion = {row, col, color};
            document.getElementById('promotionModal').style.display = 'flex';
        }
        function handlePromotionChoice(choice) {
            if (!pendingPromotion) return;
            const {row, col, color} = pendingPromotion;
            board[row][col] = (color === 'white') ? choice : choice.toLowerCase();
            // update last move promotion
            if (historyIndex >= 0 && moveHistory[historyIndex]) {
                moveHistory[historyIndex].promotion = choice;
            }
            pendingPromotion = null;
            document.getElementById('promotionModal').style.display = 'none';
            initBoard();
            updateMoveHistory();
            updateStatus();
            // After promotion, if AI's turn, trigger
            if (aiEnabled && aiPlays === currentPlayer) setTimeout(makeAIMove, 600);
        }
        // Basic material evaluation (white positive)
        function evaluateBoard() {
            const values = { 'p':1, 'n':3, 'b':3, 'r':5, 'q':9, 'k':1000 };
            let score = 0;
            for (let r=0;r<8;r++) for (let c=0;c<8;c++){ const p = board[r][c]; if (!p) continue; const v = values[p.toLowerCase()] || 0; score += (isWhitePiece(p) ? v : -v); }
            return score;
        }
        // AI move selection (uses cloud engine when API key present to play like world top player)
        async function makeAIMove(){
            if (!aiEnabled || aiPlays !== currentPlayer || isCheckmate(currentPlayer) || isStalemate(currentPlayer)) return;

            // If API key provided, prefer cloud AI (plays like world top player)
            if (apiKey && apiKey.length) {
                const statusBar = document.getElementById('statusBar');
                const prevText = statusBar.textContent;
                statusBar.textContent = 'AI thinking...';
                try {
                    const ok = await makeCloudAIMove();
                    statusBar.textContent = prevText;
                    if (ok) return;
                } catch (e) {
                    // fallback to local
                    statusBar.textContent = prevText;
                }
            }

            // local fallback
            let choice;
            if (aiLevel === 'easy') choice = pickRandomAIMove();
            else choice = pickBestAIMove(aiLevel === 'hard' ? 3 : 2);
            if (choice) {
                // slight delay for realism
                setTimeout(() => makeMove(choice.from[0], choice.from[1], choice.to[0], choice.to[1]), 200);
            }
        }

        // Convert UCI like e2e4 or e7e8q to coordinates
        function uciToCoords(uci){
            if (!uci || uci.length < 4) return null;
            const files = 'abcdefgh';
            const f1 = uci[0], r1 = parseInt(uci[1],10);
            const f2 = uci[2], r2 = parseInt(uci[3],10);
            if (files.indexOf(f1) === -1 || files.indexOf(f2) === -1 || isNaN(r1) || isNaN(r2)) return null;
            const from = [8 - r1, files.indexOf(f1)];
            const to = [8 - r2, files.indexOf(f2)];
            const promotion = uci.length >= 5 ? uci[4].toUpperCase() : null;
            return { from, to, promotion };
        }

        // Try to find JSON object inside a text blob
        function parseJSONFromText(text){
            const start = text.indexOf('{');
            const end = text.lastIndexOf('}');
            if (start === -1 || end === -1 || end <= start) return null;
            const jsonText = text.slice(start, end+1);
            try { return JSON.parse(jsonText); } catch(e){ return null; }
        }

        // Call OpenAI to get best move (JSON output required)
        async function makeCloudAIMove(){
            const fen = getBoardAsFEN();
            const prompt = `You are the world's best chess player. Given this FEN: ${fen} and the side to move: ${currentPlayer}. Return only valid JSON with keys: best_move (UCI, e.g., e2e4 or e7e8q), best_san (algebraic), pv (array of UCI moves), eval (numeric in pawns, like +0.23). Example: {"best_move":"e2e4","best_san":"e4","pv":["e2e4","e7e5"],"eval":"+0.34"}. Do not add anything else.`;

            const responseText = await callOpenAI(prompt);
            let json = null;
            try { json = JSON.parse(responseText.trim()); } catch(e) { json = parseJSONFromText(responseText); }
            if (!json || !json.best_move) return false;

            const uci = json.best_move.trim();
            const coords = uciToCoords(uci);
            if (!coords) return false;

            const legal = getPossibleMoves(coords.from[0], coords.from[1]).some(([r,c])=>r===coords.to[0] && c===coords.to[1]);
            if (!legal) {
                // fallback if model returned an illegal move
                return false;
            }

            // show the short suggestion and pv visually
            const pvMoves = (json.pv || []).map(u => uciToCoords(u)).filter(Boolean);
            showShortSuggestion({from:coords.from, to:coords.to}, pvMoves);

            // perform the move
            makeMove(coords.from[0], coords.from[1], coords.to[0], coords.to[1]);
            return true;
        }
        function pickRandomAIMove(){
            const moves = getAllLegalMovesForColor(currentPlayer);
            if (moves.length === 0) return null;
            return moves[Math.floor(Math.random()*moves.length)];
        }
        function pickBestAIMove(depth){
            const maximizing = (currentPlayer === 'white');
            let best = null;
            let bestScore = maximizing ? -Infinity : Infinity;
            const moves = getAllLegalMovesForColor(currentPlayer);
            if (moves.length === 0) return null;
            for (const m of moves){
                const prev = cloneBoard(board);
                // apply move
                const fr = m.from[0], fc = m.from[1], tr = m.to[0], tc = m.to[1];
                const moved = board[fr][fc];
                board[tr][tc] = moved; board[fr][fc] = '';
                // simplistic promotion -> queen
                if (moved.toLowerCase() === 'p' && (tr === 0 || tr === 7)) board[tr][tc] = moved === moved.toUpperCase() ? 'Q' : 'q';
                const score = minimax(depth-1, maximizing ? 'black' : 'white', -Infinity, Infinity);
                board = prev;
                if (maximizing) {
                    if (score > bestScore) { bestScore = score; best = m; }
                } else {
                    if (score < bestScore) { bestScore = score; best = m; }
                }
            }
            return best || moves[0];
        }
        function minimax(depth, color, alpha, beta){
            if (depth === 0) return evaluateBoard();
            const moves = getAllLegalMovesForColor(color);
            if (moves.length === 0) {
                if (isInCheck(color)) return color === 'white' ? -10000 : 10000; // mate
                return 0; // stalemate
            }
            if (color === 'white'){
                let maxEval = -Infinity;
                for (const m of moves){
                    const prev = cloneBoard(board);
                    const fr=m.from[0], fc=m.from[1], tr=m.to[0], tc=m.to[1];
                    const moved = board[fr][fc];
                    board[tr][tc] = moved; board[fr][fc] = '';
                    if (moved.toLowerCase() === 'p' && (tr === 0 || tr === 7)) board[tr][tc] = moved === moved.toUpperCase() ? 'Q' : 'q';
                    const evalScore = minimax(depth-1, 'black', alpha, beta);
                    board = prev;
                    maxEval = Math.max(maxEval, evalScore);
                    alpha = Math.max(alpha, evalScore);
                    if (beta <= alpha) break;
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (const m of moves){
                    const prev = cloneBoard(board);
                    const fr=m.from[0], fc=m.from[1], tr=m.to[0], tc=m.to[1];
                    const moved = board[fr][fc];
                    board[tr][tc] = moved; board[fr][fc] = '';
                    if (moved.toLowerCase() === 'p' && (tr === 0 || tr === 7)) board[tr][tc] = moved === moved.toUpperCase() ? 'Q' : 'q';
                    const evalScore = minimax(depth-1, 'white', alpha, beta);
                    board = prev;
                    minEval = Math.min(minEval, evalScore);
                    beta = Math.min(beta, evalScore);
                    if (beta <= alpha) break;
                }
                return minEval;
            }
        }
        // Utility helpers
        function isWhitePiece(piece) {
            return piece && piece === piece.toUpperCase();
        }
        function isBlackPiece(piece) {
            return piece && piece === piece.toLowerCase();
        }
        function pieceColor(piece) {
            if (!piece) return null;
            return isWhitePiece(piece) ? 'white' : 'black';
        }
        // Initialize board and UI
        function initBoard() {
            const chessboard = document.getElementById('chessboard');
            chessboard.innerHTML = '';

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    square.className = 'square ' + ((row + col) % 2 === 0 ? 'light' : 'dark');
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.onclick = () => handleSquareClick(row, col);

                    const piece = board[row][col];
                    if (piece) {
                        const pieceElement = document.createElement('span');
                        pieceElement.className = 'piece ' + (isWhitePiece(piece) ? 'white-piece' : 'black-piece');
                        pieceElement.textContent = PIECES[piece];
                        pieceElement.title = pieceColor(piece) + ' ' + piece.toUpperCase();
                        square.appendChild(pieceElement);
                    }

                    chessboard.appendChild(square);
                }
            }
            // Highlight king if in check
            const check = isInCheck(currentPlayer);
            document.querySelectorAll('.square').forEach(s => s.classList.remove('king-check'));
            if (check) {
                const kingPos = findKingPosition(currentPlayer);
                if (kingPos) {
                    const index = kingPos.row * 8 + kingPos.col;
                    document.querySelectorAll('.square')[index].classList.add('king-check');
                }
            }
            // Update score display
            document.getElementById('scoreDisplay').textContent = evaluateBoard().toFixed(1);
        }

        function handleSquareClick(row, col) {
            // clear any existing AI suggestion highlights when user interacts
            clearSuggestionHighlights();
            const clickedPiece = board[row][col];
            // If selecting own piece
            if (!selectedSquare) {
                if (clickedPiece && pieceColor(clickedPiece) === currentPlayer) {
                    selectedSquare = [row, col];
                    highlightSquare(row, col);
                    showPossibleMoves(row, col);
                }
                return;
            }
            // Try to move
            const [fromRow, fromCol] = selectedSquare;
            const legalMoves = getPossibleMoves(fromRow, fromCol);
            const isLegal = legalMoves.some(([r, c]) => r === row && c === col);
            if (isLegal) {
                makeMove(fromRow, fromCol, row, col);
            } else {
                // if clicked another friendly piece, switch selection
                if (clickedPiece && pieceColor(clickedPiece) === currentPlayer) {
                    clearSelection();
                    selectedSquare = [row, col];
                    highlightSquare(row, col);
                    showPossibleMoves(row, col);
                    return;
                }
            }
            clearSelection();
        }

        function highlightSquare(row, col) {
            const squares = document.querySelectorAll('.square');
            squares.forEach(s => s.classList.remove('selected'));
            const index = row * 8 + col;
            squares[index].classList.add('selected');
        }

        function showPossibleMoves(row, col) {
            const moves = getPossibleMoves(row, col);
            const squares = document.querySelectorAll('.square');
            squares.forEach(s => s.classList.remove('possible-move', 'has-piece'));

            moves.forEach(([toRow, toCol]) => {
                const index = toRow * 8 + toCol;
                squares[index].classList.add('possible-move');
                if (board[toRow][toCol]) squares[index].classList.add('has-piece');
            });
        }

        function clearSelection() {
            selectedSquare = null;
            const squares = document.querySelectorAll('.square');
            squares.forEach(s => {
                s.classList.remove('selected', 'possible-move', 'has-piece');
            });
        }
        // ---------- Move generation & legality ----------
        function getPossibleMoves(row, col) {
            const piece = board[row][col];
            if (!piece) return [];
            const color = pieceColor(piece);
            const moves = [];
            const type = piece.toLowerCase();
            // Pawn moves
            if (type === 'p') {
                const dir = color === 'white' ? -1 : 1;
                const startRow = color === 'white' ? 6 : 1;
                // One forward
                if (inBounds(row + dir, col) && !board[row + dir][col]) moves.push([row + dir, col]);
                // Two forward from start
                if (row === startRow && !board[row + dir][col] && !board[row + dir*2][col]) moves.push([row + dir*2, col]);
                // Captures
                [[dir, -1], [dir, 1]].forEach(([dr, dc]) => {
                    const r = row + dr, c = col + dc;
                    if (inBounds(r, c) && board[r][c] && pieceColor(board[r][c]) !== color) moves.push([r, c]);
                    // en-passant capture
                    if (enPassantTarget && enPassantTarget.row === r && enPassantTarget.col === c) {
                        moves.push([r, c]);
                    }
                });
            }
            // Knight
            if (type === 'n') {
                const km = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
                km.forEach(([dr, dc]) => {
                    const r = row + dr, c = col + dc;
                    if (inBounds(r,c) && (!board[r][c] || pieceColor(board[r][c]) !== color)) moves.push([r,c]);
                });
            }
            // Sliding pieces
            if (type === 'b' || type === 'r' || type === 'q') {
                const dirs = [];
                if (type === 'b' || type === 'q') dirs.push(...[[1,1],[1,-1],[-1,1],[-1,-1]]);
                if (type === 'r' || type === 'q') dirs.push(...[[1,0],[-1,0],[0,1],[0,-1]]);
                dirs.forEach(([dr,dc]) => addSlidingMovesFrom(row,col,dr,dc,color,moves));
            }
            // King (including castling)
            if (type === 'k') {
                for (let dr=-1; dr<=1; dr++) for (let dc=-1; dc<=1; dc++){
                    if (dr===0 && dc===0) continue;
                    const r = row+dr, c = col+dc;
                    if (inBounds(r,c) && (!board[r][c] || pieceColor(board[r][c]) !== color)) moves.push([r,c]);
                }
                // Castling
                if (color === 'white' && row === 7 && col === 4) {
                    // kingside
                    if (castling.wK && !board[7][5] && !board[7][6] && !isSquareAttacked(board,7,4,'black') && !isSquareAttacked(board,7,5,'black') && !isSquareAttacked(board,7,6,'black')) moves.push([7,6]);
                    // queenside
                    if (castling.wQ && !board[7][3] && !board[7][2] && !board[7][1] && !isSquareAttacked(board,7,4,'black') && !isSquareAttacked(board,7,3,'black') && !isSquareAttacked(board,7,2,'black')) moves.push([7,2]);
                }
                if (color === 'black' && row === 0 && col === 4) {
                    if (castling.bK && !board[0][5] && !board[0][6] && !isSquareAttacked(board,0,4,'white') && !isSquareAttacked(board,0,5,'white') && !isSquareAttacked(board,0,6,'white')) moves.push([0,6]);
                    if (castling.bQ && !board[0][3] && !board[0][2] && !board[0][1] && !isSquareAttacked(board,0,4,'white') && !isSquareAttacked(board,0,3,'white') && !isSquareAttacked(board,0,2,'white')) moves.push([0,2]);
                }
            }
            // Filter out moves that leave own king in check
            const legal = moves.filter(([toR,toC]) => {
                const testBoard = cloneBoard(board);
                const movingPiece = testBoard[row][col];
                // handle en-passant capture removal in simulation
                if (type === 'p' && enPassantTarget && toR === enPassantTarget.row && toC === enPassantTarget.col && Math.abs(toC - col) === 1 && !testBoard[toR][toC]) {
                    const capRow = row; // pawn being captured is on same row as moving pawn
                    testBoard[capRow][toC] = '';
                }
                testBoard[toR][toC] = movingPiece;
                testBoard[row][col] = '';
                // castling rook move in simulation
                if (type === 'k' && Math.abs(toC - col) === 2) {
                    if (toC === 6) { // kingside
                        testBoard[row][5] = testBoard[row][7];
                        testBoard[row][7] = '';
                    } else if (toC === 2) { // queenside
                        testBoard[row][3] = testBoard[row][0];
                        testBoard[row][0] = '';
                    }
                }
                const kp = findKingPositionOnBoard(testBoard, color);
                if (!kp) return false; // no king found — treat as illegal
                return !isSquareAttacked(testBoard, kp.row, kp.col, color === 'white' ? 'black' : 'white');
            });
            return legal;
        }
        function addSlidingMovesFrom(row,col,dr,dc,color,moves){
            let r = row+dr, c = col+dc;
            while (inBounds(r,c)){
                if (!board[r][c]) { moves.push([r,c]); }
                else { if (pieceColor(board[r][c]) !== color) moves.push([r,c]); break; }
                r += dr; c += dc;
            }
        }
        function inBounds(r,c){return r>=0 && r<8 && c>=0 && c<8;}
        // ---------- Attack & check detection ----------
        function isSquareAttacked(bd, row, col, byColor){
            // Pawns
            const pawnDir = byColor === 'white' ? -1 : 1;
            const pawnRows = [[row - pawnDir, col - 1], [row - pawnDir, col + 1]];
            for (const [r,c] of pawnRows) if (inBounds(r,c) && bd[r][c] && pieceColor(bd[r][c]) === byColor && bd[r][c].toLowerCase() === 'p') return true;
            // Knights
            const km = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
            for (const [dr,dc] of km){ const r=row+dr, c=col+dc; if (inBounds(r,c) && bd[r][c] && pieceColor(bd[r][c])===byColor && bd[r][c].toLowerCase()==='n') return true; }
            // Sliding: bishop/queen diagonals
            const diags = [[1,1],[1,-1],[-1,1],[-1,-1]];
            for (const [dr,dc] of diags){ let r=row+dr, c=col+dc; while(inBounds(r,c)){ if (bd[r][c]){ if (pieceColor(bd[r][c])===byColor && (bd[r][c].toLowerCase()==='b' || bd[r][c].toLowerCase()==='q')) return true; break; } r+=dr; c+=dc; }}
            // Sliding: rook/queen orthogonals
            const orth = [[1,0],[-1,0],[0,1],[0,-1]];
            for (const [dr,dc] of orth){ let r=row+dr, c=col+dc; while(inBounds(r,c)){ if (bd[r][c]){ if (pieceColor(bd[r][c])===byColor && (bd[r][c].toLowerCase()==='r' || bd[r][c].toLowerCase()==='q')) return true; break; } r+=dr; c+=dc; }}
            // King
            for (let dr=-1; dr<=1; dr++) for (let dc=-1; dc<=1; dc++){ if (dr===0 && dc===0) continue; const r=row+dr,c=col+dc; if (inBounds(r,c) && bd[r][c] && pieceColor(bd[r][c])===byColor && bd[r][c].toLowerCase()==='k') return true; }
            return false;
        }
        function findKingPosition(color){
            for (let r=0;r<8;r++) for (let c=0;c<8;c++){ if (board[r][c] && board[r][c].toLowerCase()==='k' && pieceColor(board[r][c])===color) return {row:r,col:c}; }
            return null;
        }
        function findKingPositionOnBoard(bd, color){
            for (let r=0;r<8;r++) for (let c=0;c<8;c++){ if (bd[r][c] && bd[r][c].toLowerCase()==='k' && pieceColor(bd[r][c])===color) return {row:r,col:c}; }
            return null;
        }
        function isInCheck(color){
            const kp = findKingPosition(color);
            if (!kp) return false;
            return isSquareAttacked(board, kp.row, kp.col, color === 'white' ? 'black' : 'white');
        }
        function getAllLegalMovesForColor(color){
            const moves = [];
            for (let r=0;r<8;r++) for (let c=0;c<8;c++){ if (board[r][c] && pieceColor(board[r][c])===color){ const m = getPossibleMoves(r,c); if (m.length) m.forEach(to => moves.push({from:[r,c],to})); }}
            return moves;
        }
        function isCheckmate(color){
            return isInCheck(color) && getAllLegalMovesForColor(color).length === 0;
        }
        function isStalemate(color){
            return !isInCheck(color) && getAllLegalMovesForColor(color).length === 0;
        }
        function cloneBoard(bd){ return JSON.parse(JSON.stringify(bd)); }
        // ---------- AI Suggestion helpers (short & visual) ----------
        let latestSuggestion = null;
        let latestPV = null;
        function coordsToAlgebraic([r,c]){
            const files = ['a','b','c','d','e','f','g','h'];
            return files[c] + (8 - r);
        }
        function clearSuggestionHighlights(){
            document.querySelectorAll('.square').forEach(s => s.classList.remove('suggest-from','suggest-to','suggest-line'));
        }
        function highlightSuggestion(move, pv){
            clearSuggestionHighlights();
            if (!move) return;
            const fromIndex = move.from[0]*8 + move.from[1];
            const toIndex = move.to[0]*8 + move.to[1];
            const squares = document.querySelectorAll('.square');
            if (squares[fromIndex]) squares[fromIndex].classList.add('suggest-from');
            if (squares[toIndex]) squares[toIndex].classList.add('suggest-to');
            // highlight PV path squares lightly
            if (pv && pv.length){
                pv.slice(1).forEach(m => {
                    const idx = m.to[0]*8 + m.to[1];
                    if (squares[idx]) squares[idx].classList.add('suggest-line');
                });
            }
        }
        function applySuggestion(){
            if (!latestSuggestion) return;
            const m = latestSuggestion;
            clearSuggestionHighlights();
            makeMove(m.from[0], m.from[1], m.to[0], m.to[1]);
        }
        function getPrincipalVariation(maxPly){
            // Builds a simple PV by repeatedly choosing the best move for side to move up to maxPly
            const backupBoard = cloneBoard(board);
            const backupPlayer = currentPlayer;
            const pv = [];
            for (let ply=0; ply<maxPly; ply++) {
                const best = pickBestAIMove(ply>=2?3:2); // try slightly deeper for early plies
                if (!best) break;
                pv.push(best);
                // apply on board
                board[best.to[0]][best.to[1]] = board[best.from[0]][best.from[1]];
                board[best.from[0]][best.from[1]] = '';
                // switch player
                currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            }
            // restore
            board = backupBoard;
            currentPlayer = backupPlayer;
            return pv;
        }
        function showShortSuggestion(move, pv){
            latestSuggestion = move; latestPV = pv;
            const analysisDiv = document.getElementById('analysisContent');
            clearSuggestionHighlights();
            if (!move) {
                analysisDiv.innerHTML = '<div style="color:var(--text-secondary)">No clear suggested move.</div>';
                return;
            }
            const algFrom = coordsToAlgebraic(move.from);
            const algTo = coordsToAlgebraic(move.to);
            const score = evaluateBoardAfterMove(move);
            const scoreStr = (score>0?'+':'') + score.toFixed(2);
            let pvStr = '';
            if (pv && pv.length){ pvStr = `Line: ${pv.map(m=>coordsToAlgebraic(m.from)+coordsToAlgebraic(m.to)).join(' ')}`; }
            analysisDiv.innerHTML = `
                <div style="display:flex; gap:0.6rem; align-items:center;">
                    <div><strong>Best:</strong> ${algFrom} → ${algTo} <small>(${scoreStr})</small></div>
                    <button class="btn btn-small" onclick="applySuggestion()">Apply</button>
                    <button class="btn btn-small" onclick="document.getElementById('analysisDetails').style.display = (document.getElementById('analysisDetails').style.display==='none'? 'block' : 'none')">Details</button>
                </div>
                <div style="color:var(--text-secondary); font-size:0.9rem; margin-top:0.5rem;">${pvStr}</div>
                <div id="analysisDetails" style="display:none; margin-top:0.6rem; color:var(--text-secondary);"></div>
            `;
            highlightSuggestion(move, pv);
        }
        function evaluateBoardAfterMove(move){
            const prev = cloneBoard(board);
            const fr = move.from[0], fc = move.from[1], tr = move.to[0], tc = move.to[1];
            const moved = board[fr][fc];
            board[tr][tc] = moved; board[fr][fc] = '';
            const score = evaluateBoard();
            board = prev;
            return score;
        }
        function makeMove(fromRow, fromCol, toRow, toCol) {
            // Truncate future history if we're not at the end
            if (historyIndex < moveHistory.length - 1) {
                moveHistory = moveHistory.slice(0, historyIndex + 1);
            }
            const piece = board[fromRow][fromCol];
            const capturedPiece = board[toRow][toCol];
            const move = {
                from: [fromRow, fromCol],
                to: [toRow, toCol],
                piece: piece,
                captured: capturedPiece,
                enPassant: enPassantTarget ? {...enPassantTarget} : null,
                castling: null,
                promotion: null
            };
            // Handle en-passant capture
            if (piece.toLowerCase() === 'p' && enPassantTarget && toRow === enPassantTarget.row && toCol === enPassantTarget.col && !capturedPiece) {
                // captured pawn is on the previous row of the moving pawn
                const capRow = fromRow;
                move.captured = board[capRow][toCol];
                board[capRow][toCol] = '';
            }
            // Handle castling rook movement
            if (piece.toLowerCase() === 'k' && Math.abs(toCol - fromCol) === 2) {
                if (toCol === 6) { // kingside
                    board[toRow][5] = board[toRow][7];
                    board[toRow][7] = '';
                    move.castling = 'K';
                } else if (toCol === 2) { // queenside
                    board[toRow][3] = board[toRow][0];
                    board[toRow][0] = '';
                    move.castling = 'Q';
                }
            }
            // Move piece
            board[toRow][toCol] = board[fromRow][fromCol];
            board[fromRow][fromCol] = '';
            // Pawn promotion: default to queen, show modal for human to override
            if (piece.toLowerCase() === 'p' && (toRow === 0 || toRow === 7)) {
                board[toRow][toCol] = currentPlayer === 'white' ? 'Q' : 'q';
                move.promotion = 'Q';
                // if human moved, show modal to let user choose promotion
                if (!aiEnabled || aiPlays !== currentPlayer) {
                    showPromotionModal(toRow, toCol, currentPlayer);
                    // Pause further execution until promotion chosen
                    return; // Important: stop here until choice made
                }
            }
            clearSuggestionHighlights();
            moveHistory.push(move);
            historyIndex++;
            animateMove(fromRow, fromCol, toRow, toCol);
            // Switch player
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            // Update castling rights
            if (piece === 'K') { castling.wK = castling.wQ = false; }
            if (piece === 'k') { castling.bK = castling.bQ = false; }
            if (piece === 'R' && fromRow === 7 && fromCol === 0) castling.wQ = false;
            if (piece === 'R' && fromRow === 7 && fromCol === 7) castling.wK = false;
            if (piece === 'r' && fromRow === 0 && fromCol === 0) castling.bQ = false;
            if (piece === 'r' && fromRow === 0 && fromCol === 7) castling.bK = false;
            // If rook was captured, update rights
            if (capturedPiece === 'R' && toRow === 7 && toCol === 0) castling.wQ = false;
            if (capturedPiece === 'R' && toRow === 7 && toCol === 7) castling.wK = false;
            if (capturedPiece === 'r' && toRow === 0 && toCol === 0) castling.bQ = false;
            if (capturedPiece === 'r' && toRow === 0 && toCol === 7) castling.bK = false;
            // Set en-passant target if pawn moved two squares
            if (piece.toLowerCase() === 'p' && Math.abs(toRow - fromRow) === 2) {
                enPassantTarget = {row: (fromRow + toRow) / 2, col: fromCol};
            } else {
                enPassantTarget = null;
            }
            initBoard();
            updateMoveHistory();
            updateStatus();
            updateNavigationButtons();
            document.getElementById('afterMoveBtn').disabled = false;
            lastMoveMade = move;
            // Alerts if check / checkmate / stalemate
            const inCheck = isInCheck(currentPlayer);
            if (inCheck) {
                alert('Check!');
                document.getElementById('statusBar').classList.add('check');
            }
            if (isCheckmate(currentPlayer)) {
                alert('Checkmate! ' + (currentPlayer === 'white' ? 'Black' : 'White') + ' wins');
                document.getElementById('statusBar').classList.add('checkmate');
            } else if (isStalemate(currentPlayer)) {
                alert('Stalemate! Draw');
            }
            // If AI enabled and it's AI's turn, let it move
            if (aiEnabled && aiPlays === currentPlayer && !isCheckmate(currentPlayer) && !isStalemate(currentPlayer)) {
                setTimeout(makeAIMove, 400);
            }
        }
        function animateMove(fromRow, fromCol, toRow, toCol) {
            const fromIndex = fromRow * 8 + fromCol;
            const squares = document.querySelectorAll('.square');
            const pieceElement = squares[fromIndex].querySelector('.piece');
            if (pieceElement) {
                pieceElement.classList.add('moving');
                setTimeout(() => {
                    pieceElement.classList.remove('moving');
                }, 500);
            }
        }
        function updateMoveHistory() {
            const historyDiv = document.getElementById('moveHistory');
            if (moveHistory.length === 0) {
                historyDiv.innerHTML = '<p style="color: var(--text-secondary);">No moves yet</p>';
                return;
            }
            historyDiv.innerHTML = '';
            moveHistory.forEach((move, index) => {
                const moveItem = document.createElement('div');
                moveItem.className = `move-item ${index === historyIndex ? 'active' : ''}`;
                moveItem.onclick = () => goToMove(index);
                const moveNumber = Math.floor(index / 2) + 1;
                const isWhite = index % 2 === 0;
                const notation = getMoveNotation(move);
                moveItem.innerHTML = `<span class="move-number">${moveNumber}${isWhite ? '.' : '...'}</span> ${notation}`;
                historyDiv.appendChild(moveItem);
            });
            historyDiv.scrollTop = historyDiv.scrollHeight;
        }
        function getMoveNotation(move) {
            const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            const pieceSymbols = { 'k': '', 'q': 'Q', 'r': 'R', 'b': 'B', 'n': 'N', 'p': '' };
            const piece = move.piece.toLowerCase();
            const symbol = pieceSymbols[piece] || '';
            const capture = move.captured ? 'x' : '';
            const toSquare = files[move.to[1]] + (8 - move.to[0]);
            const promo = move.promotion ? `=${move.promotion}` : '';
            return `${symbol}${capture}${toSquare}${promo}`;
        }
        function goToMove(index) {
            if (index < -1 || index >= moveHistory.length) return;
            board = JSON.parse(JSON.stringify(INITIAL_BOARD));
            castling = { wK: true, wQ: true, bK: true, bQ: true };
            enPassantTarget = null;
            if (index === -1) {
                currentPlayer = 'white';
                historyIndex = -1;
            } else {
                for (let i = 0; i <= index; i++) {
                    const m = moveHistory[i];
                    const [fr, fc] = m.from;
                    const [tr, tc] = m.to;
                    const piece = m.piece;
                    if (m.captured && m.enPassant) {
                        const capRow = fr;
                        board[capRow][tc] = '';
                    }
                    if (m.castling) {
                        if (m.castling === 'K') {
                            board[tr][5] = board[tr][7];
                            board[tr][7] = '';
                        } else if (m.castling === 'Q') {
                            board[tr][3] = board[tr][0];
                            board[tr][0] = '';
                        }
                    }
                    board[tr][tc] = piece;
                    board[fr][fc] = '';
                    if (m.promotion) {
                        board[tr][tc] = (pieceColor(piece) === 'white' ? m.promotion : m.promotion.toLowerCase());
                    }
                    // Update states (simplified, assuming full reset each time)
                    if (piece === 'K') { castling.wK = castling.wQ = false; }
                    if (piece === 'k') { castling.bK = castling.bQ = false; }
                    if (piece === 'R' && fr === 7 && fc === 0) castling.wQ = false;
                    if (piece === 'R' && fr === 7 && fc === 7) castling.wK = false;
                    if (piece === 'r' && fr === 0 && fc === 0) castling.bQ = false;
                    if (piece === 'r' && fr === 0 && fc === 7) castling.bK = false;
                    if (m.captured === 'R' && tr === 7 && tc === 0) castling.wQ = false;
                    if (m.captured === 'R' && tr === 7 && tc === 7) castling.wK = false;
                    if (m.captured === 'r' && tr === 0 && tc === 0) castling.bQ = false;
                    if (m.captured === 'r' && tr === 0 && tc === 7) castling.bK = false;
                    if (piece.toLowerCase() === 'p' && Math.abs(tr - fr) === 2) {
                        enPassantTarget = {row: (fr + tr) / 2, col: fc};
                    } else {
                        enPassantTarget = null;
                    }
                }
                historyIndex = index;
                currentPlayer = (index % 2 === 0) ? 'black' : 'white';
            }
            initBoard();
            updateMoveHistory();
            updateStatus();
            updateNavigationButtons();
        }
        function previousMove() { if (historyIndex > -1) goToMove(historyIndex - 1); }
        function nextMove() { if (historyIndex < moveHistory.length - 1) goToMove(historyIndex + 1); }
        function updateNavigationButtons() {
            document.getElementById('prevBtn').disabled = historyIndex <= -1;
            document.getElementById('nextBtn').disabled = historyIndex >= moveHistory.length - 1;
        }
        function updateStatus() {
            const statusBar = document.getElementById('statusBar');
            statusBar.className = 'status-bar';
            const check = isInCheck(currentPlayer);
            if (check) statusBar.classList.add('check');
            if (isCheckmate(currentPlayer)) statusBar.classList.add('checkmate');
            statusBar.textContent = `${currentPlayer === 'white' ? 'White' : 'Black'} to move` + (check ? ' - Check!' : '');
        }
        function resetGame() {
            board = JSON.parse(JSON.stringify(INITIAL_BOARD));
            currentPlayer = 'white';
            moveHistory = [];
            historyIndex = -1;
            lastMoveMade = null;
            selectedSquare = null;
            enPassantTarget = null;
            castling = { wK: true, wQ: true, bK: true, bQ: true };
            initBoard();
            clearSuggestionHighlights();
            updateMoveHistory();
            updateStatus();
            updateNavigationButtons();
            document.getElementById('analysisContent').textContent = 'Game reset. Make a move to get AI coaching.';
            document.getElementById('scoreDisplay').textContent = '0.0';
            document.getElementById('afterMoveBtn').disabled = true;
        }
        function saveApiKey() {
            apiKey = document.getElementById('apiKey').value.trim();
            if (apiKey) {
                alert('API Key saved! You can now use AI coaching features.');
            } else {
                alert('Please enter a valid API key.');
            }
        }
        function getBoardAsFEN() {
            let fen = '';
            for (let row = 0; row < 8; row++) {
                let emptyCount = 0;
                for (let col = 0; col < 8; col++) {
                    const piece = board[row][col];
                    if (piece) {
                        if (emptyCount > 0) {
                            fen += emptyCount;
                            emptyCount = 0;
                        }
                        fen += piece;
                    } else {
                        emptyCount++;
                    }
                }
                if (emptyCount > 0) fen += emptyCount;
                if (row < 7) fen += '/';
            }
            let cast = '';
            if (castling.wK) cast += 'K';
            if (castling.wQ) cast += 'Q';
            if (castling.bK) cast += 'k';
            if (castling.bQ) cast += 'q';
            if (cast === '') cast = '-';
            let ep = '-';
            if (enPassantTarget) {
                const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
                ep = files[enPassantTarget.col] + (8 - enPassantTarget.row);
            }
            fen += ` ${currentPlayer === 'white' ? 'w' : 'b'} ${cast} ${ep} 0 1`;
            return fen;
        }
        async function analyzeBeforeMove() {
            const analysisDiv = document.getElementById('analysisContent');
            analysisDiv.innerHTML = '<div class="loading"></div> Analyzing position...';
            // Local engine suggestion (short & visual)
            const depth = aiLevel === 'hard' ? 3 : (aiLevel === 'medium' ? 2 : 1);
            const suggestion = pickBestAIMove(depth);
            const pv = suggestion ? getPrincipalVariation(3) : null;
            showShortSuggestion(suggestion, pv);
            // If API key set, fetch detailed analysis from OpenAI and put it in the details section
            if (!apiKey) {
                // no API key — keep local short suggestion
                return;
            }
            const fen = getBoardAsFEN();
            const prompt = getGrandmasterPrompt('before', fen);
            try {
                const analysis = await callOpenAI(prompt);
                const detailsDiv = document.getElementById('analysisDetails');
                if (detailsDiv) detailsDiv.innerHTML = analysis;
            } catch (error) {
                const detailsDiv = document.getElementById('analysisDetails');
                if (detailsDiv) detailsDiv.innerHTML = `<span style="color: var(--error);">Error: ${error.message}</span>`;
            }
        }
        async function analyzeAfterMove() {
            const analysisDiv = document.getElementById('analysisContent');
            analysisDiv.innerHTML = '<div class="loading"></div> Analyzing your move...';
            if (!lastMoveMade) { analysisDiv.innerHTML = '<div style="color:var(--text-secondary)">Make a move first to analyze it.</div>'; return; }
            // Local evaluation and suggestion (short)
            const depth = aiLevel === 'hard' ? 3 : (aiLevel === 'medium' ? 2 : 1);
            const suggestion = pickBestAIMove(depth);
            const pv = suggestion ? getPrincipalVariation(3) : null;
            showShortSuggestion(suggestion, pv);
            // If API key set, fetch richer feedback from OpenAI and show in details
            if (!apiKey) return;
            const fen = getBoardAsFEN();
            const moveNotation = getMoveNotation(lastMoveMade);
            const previousPlayer = currentPlayer === 'white' ? 'black' : 'white';
            const prompt = getGrandmasterPrompt('after', fen, moveNotation, previousPlayer);
            try {
                const analysis = await callOpenAI(prompt);
                const detailsDiv = document.getElementById('analysisDetails');
                if (detailsDiv) detailsDiv.innerHTML = analysis;
            } catch (error) {
                const detailsDiv = document.getElementById('analysisDetails');
                if (detailsDiv) detailsDiv.innerHTML = `<span style="color: var(--error);">Error: ${error.message}</span>`;
            }
        }
        function getGrandmasterPrompt(mode, fen, lastMove = null, previousPlayer = null) {
            if (mode === 'before') {
                return `You are the world's greatest chess grandmaster and coach, with a deep understanding of chess strategy, tactics, and endgame theory comparable to Magnus Carlsen, Garry Kasparov, and Mikhail Tal combined. Your goal is to guide the player to become the universe's no1 chess player by teaching all tricks, tactics, and strategies.

Current Position (FEN): ${fen}

TASK: Provide a comprehensive analysis of the current position and recommend the absolute best move(s) for the player to move (${currentPlayer}).

Your analysis MUST include:
1. Overall position assessment: Who has the advantage? By how much (e.g., slight edge, winning, equal)? Key factors like material, pawn structure, piece activity, king safety, control of center/open files.
2. Potential tactics: Any immediate tactics, forks, pins, discovered attacks, etc., for either side.
3. Strategic plans: Long-term ideas for both sides, like minority attack, king-side assault, endgame transition.
4. Top move recommendations: Suggest 1-3 best moves, with main variations (3-5 moves deep), expected outcomes, and why they are strong (e.g., gains material, improves position).
5. Tricks and tactics: Highlight any clever tricks in the variations.
6. General advice: What general chess principles apply here? What can the player learn to become universe's no1 player.

Structure your response in markdown with headings for readability. Be encouraging but honest to help the player improve to super grandmaster level.`;
            } else {
                return `You are the world's greatest chess grandmaster and coach analyzing a student's move. Your goal is to help the player become the universe's no1 chess player by pointing out all tricks, tactics, and strategies they missed or used.

Position AFTER the move (FEN): ${fen}
Move played by ${previousPlayer}: ${lastMove}

TASK: Provide brutally honest, world-class analysis of this move.

Include:
1. Move evaluation: Brilliant, good, average, mistake, blunder? Why? What is the centipawn loss if approximate.
2. Better alternatives: What was the best move? Show variation and why better.
3. Tactics involved/missed: Did the move allow/prevent tactics? Any tricks the player missed.
4. Strategic impact: How does it affect position? Improved/worsened key factors.
5. Lessons: What tactics/strategy principle to learn? How to avoid similar errors or spot such opportunities.
6. Encouragement: Positive feedback if good, motivational advice to improve.

Use markdown structure. Be detailed with variations to teach deeply.`;
            }
        }
        async function callOpenAI(prompt) {
            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({ model: 'gpt-4o', messages: [{ role: 'system', content: 'You are the world\'s greatest chess grandmaster, combining the strategic depth of Garry Kasparov, the tactical brilliance of Mikhail Tal, and the endgame mastery of Magnus Carlsen. You provide world-class chess coaching with specific, actionable advice backed by concrete calculation.'}, { role: 'user', content: prompt }], temperature: 0.7, max_tokens: 2000 })
            });
            if (!response.ok) { const error = await response.json(); throw new Error(error.error?.message || 'API request failed'); }
            const data = await response.json();
            return data.choices[0].message.content;
        }
        // Initialize
        initBoard();
        updateStatus();

    </script>
</body>
</html>